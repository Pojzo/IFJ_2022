bool rule_expr(token_storage_t *token_storage) {
    static int num_calls = 0;
    for (int i = 0; i< 50; i++) {
        // print num_calls and increment it
        //printf("%d %s\n", num_calls, get_token_keep(token_storage)->value);
    }
    num_calls++;
    //get_token(token_storage);
    //return 1;
    int left_brackets = 0;
    list_t *list = list_init();
    symbol_enum input;
    symbol_enum top;
    bool valid;

    symbol_enum symbol1 = INT;
    symbol_enum symbol2 = INT;
    symbol_enum symbol3 = INT;
    int numsym = 0;

    int error = 0;

    assoc_t prec_operator; 
    bool input_loaded = false;

    while (!input_loaded || !(final_condition(list))) { //TODO 
        if (!input_loaded) {
            token_t *token = get_token_keep(token_storage);
            if (strcmp(token->value, "(") == 0) {
                left_brackets++;
            }

            else if (strcmp(token->value, ")") == 0) {
                left_brackets--;
                if (left_brackets < 0) {
                    input_loaded = true;
                }
            }
            //MAKE SYMBOL OUT OF TOKEN 
            top = list_get_first_term(&list);
            input = convert_token_to_symbol(token, &valid);
            if (valid == 0){
                input_loaded = 1;
                input = DOLLAR;
            }
        }
        else {
            input = DOLLAR;
            top = list_get_first_term(&list);
        }
        // tuto dame ten oprator ktory budeme musiet pozuit, takze bud <, >, =, x, alebo koniec
        prec_operator = prec_table[convert_symbol_to_int(top)][convert_symbol_to_int(input)];
        printf("top je %d, input je %d, operator je %d, konvertovane: %d, %d, realny token je %s %d, valid je tato picovina %d\n", top, input, prec_operator, convert_symbol_to_int(top), convert_symbol_to_int(input), get_token_keep(token_storage)->value, input_loaded == true, valid);
        // na zaklade toho aky je to operator tak rozhodneme co budeme robit 
        if (prec_operator == L_A) {        
            if(!return_before_stop(&list, &symbol1, &symbol2, &symbol3, &numsym)){
                error = 0;
                goto end;
            }
            if(rule_check(&symbol1, &symbol2, &symbol3, numsym))
            {        
                list_insert_first(&list, NONTERM);
                print_list(list);
                if (input_loaded && final_condition(list)) {
                    error = 1;
                    goto end;
                }
            }
            else {
                error = 0;
                goto end;
            }
        }
        // <
        else if (prec_operator == R_A) {   
            list_insert_after_nonterm(&list);
            list_insert_first(&list, input);
            print_list(list);
            if(!input_loaded) {
                get_token(token_storage);
            }

           
        }
        else if (prec_operator == EQ_A) {
            list_insert_first(&list, input);
            print_list(list);
            if(!input_loaded) {
                get_token(token_storage);
            }


        }
        else if (prec_operator == ERR) {
            error = 0;
            goto end;
        }
        else if (prec_operator == END) {
            error = 1;
            goto end;
        }
    }
    end:
    list_free(list);
    return error;
} 